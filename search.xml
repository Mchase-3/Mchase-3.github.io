<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>暴力数据结构-珂朵莉树(ODT)</title>
    <url>/2020/%E6%9A%B4%E5%8A%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91-ODT/</url>
    <content><![CDATA[<h3 id="暴力数据结构-珂朵莉树-ODT"><a href="#暴力数据结构-珂朵莉树-ODT" class="headerlink" title="暴力数据结构-珂朵莉树(ODT)"></a>暴力数据结构-珂朵莉树(ODT)</h3><p><img src="暴力数据结构-珂朵莉树-ODT\001.jpg" alt="珂朵莉"></p>
<p>（图片来自<a href="https://www.bilibili.com/read/cv146458?from=category_2" target="_blank" rel="noopener">哔哩哔哩</a>）</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>珂朵莉树(Chtholly Tree，又称Old Driver Tree(ODT))</strong>，据说来源于<a href="https://codeforces.com/problemset/problem/896/C" target="_blank" rel="noopener">CF896C</a>，此题要求支持下列操作：</p>
<ul>
<li>区间加</li>
<li>区间赋值</li>
<li>求区间第 $k$ 小值</li>
<li>求区间 $n$ 次方和</li>
</ul>
<p>看上去似乎普通的数据结构如线段树、平衡树等无法处理，需要一种巧妙复杂的数据结构。但出题人（<a href="https://www.zhihu.com/people/olddrivertree" target="_blank" rel="noopener">@lxl</a>）的题解中所实现的却是一种十分暴力的数据结构，后来称作珂朵莉树。</p>
<h4 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h4><p>一般用于具有<strong>区间赋值且数据随机</strong>的题目。在随机数据的情况下，其时间复杂度可以达到 $O(n \log \log n)$ （<a href="https://zhuanlan.zhihu.com/p/102786071" target="_blank" rel="noopener">证明</a>）。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h5><p>珂朵莉树以三元组 $<L,R,V>$ 的方式储存数据，表示区间 $[L,R]$ 中的数的值均为 $V$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> L,R;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> V;</span><br><span class="line">	Node (<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v) : L(l),R(r),V(v) &#123;&#125;;<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> L&lt;b.L;&#125;<span class="comment">//重载小于运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意 $V$ 的前缀 <code>mutable</code>，意为“可变的”，当整个结构体为const时，由它修饰的成员标仍然可以修改。</p>
<p>用 <code>set</code> 储存这些三元组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;Node&gt; T;</span><br></pre></td></tr></table></figure>
<p>这样，插入、查询、修改的时间就均为 $O(\log n)$ 啦。<del>(当然，你也可以自己写以个平衡树QAQ)</del></p>
<h5 id="核心操作："><a href="#核心操作：" class="headerlink" title="核心操作："></a>核心操作：</h5><ul>
<li>$\operatorname{Split}$</li>
</ul>
<p>$\operatorname{Split}$ 操作是将一个区间分裂为两个区间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Auto set <span class="meta-string">&lt;Node&gt; :: iterator //如果支持c++11，可以直接使用auto</span></span></span><br><span class="line"><span class="function">Auto <span class="title">Split</span><span class="params">(<span class="keyword">int</span> Pos)</span> </span>&#123;</span><br><span class="line">	Auto it= T.lower_bound(Node(Pos,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//找到第一个L不小于Pos的区间</span></span><br><span class="line">	<span class="keyword">if</span>(it!=T.<span class="built_in">end</span>() &amp;&amp; it-&gt;L==Pos) <span class="keyword">return</span> it;<span class="comment">//如果不需要Split，就直接返回</span></span><br><span class="line">	--it;<span class="comment">//找到Pos所在的区间</span></span><br><span class="line">	<span class="keyword">int</span> L=it-&gt;L,R=it-&gt;R,V=it-&gt;V;</span><br><span class="line">	T.erase(it),T.insert(Node(L,Pos<span class="number">-1</span>,V));</span><br><span class="line">	<span class="keyword">return</span> T.insert(Node(Pos,R,V)).first;</span><br><span class="line">    <span class="comment">//删除原区间，插入两个新分裂的区间，返回后插入的区间</span></span><br><span class="line">    <span class="comment">//这里利用了pair&lt;iterator,bool&gt; insert (const value_type&amp; val)的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>$\operatorname{Assign}$</li>
</ul>
<p><strong>$\operatorname{Assign}$</strong> 函数是珂朵莉树保证其复杂度的核心，即<strong>区间赋值</strong>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">	Auto itR=Split(R+<span class="number">1</span>),itL=Split(L);</span><br><span class="line">    <span class="comment">//值得注意的是，此处顺序不能颠倒，否则可能RE</span></span><br><span class="line">    <span class="comment">//因为若先Split(L),那么Split(R)有可能使itL所指向的区间分裂,则删除itL~itR时会出错</span></span><br><span class="line">	T.erase(itL,itR),T.insert(Node(L,R,V));<span class="comment">//消除范围内的所有区间，再插入合并后的区间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于数据随机，会有大量的<strong>区间赋值</strong>操作，这样会迅速的缩小 $\operatorname{set}$ 的大小，保证其复杂度。</p>
<h5 id="其他操作：-暴力大法好"><a href="#其他操作：-暴力大法好" class="headerlink" title="其他操作：(暴力大法好)"></a>其他操作：<del>(暴力大法好)</del></h5><ul>
<li>区间加法：</li>
</ul>
<p>一个一个加 Σ(っ°Д°;)っ</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">	Auto itR=Split(R+<span class="number">1</span>),itL=Split(L);</span><br><span class="line">	<span class="keyword">for</span>(; itL!=itR; ++itL) itL-&gt;V+=V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>求区间第 $k$ 小值</li>
</ul>
<p>暴力取出并排序 !!!∑(ﾟДﾟノ)ノ</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rank</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; Temp;</span><br><span class="line">	Auto itR=Split(R+<span class="number">1</span>),itL=Split(L);</span><br><span class="line">	Temp.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(; itL!=itR; ++itL) Temp.push_back(pair&lt;ll,ll&gt;(itL-&gt;V,itL-&gt;R-itL-&gt;L+<span class="number">1</span>));</span><br><span class="line">	sort(Temp.<span class="built_in">begin</span>(),Temp.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; :: iterator it=Temp.<span class="built_in">begin</span>(); it!=Temp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">		K-=it-&gt;second;</span><br><span class="line">		<span class="keyword">if</span>(K&lt;=<span class="number">0</span>) <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>求区间 $n$ 次方和</li>
</ul>
<p>暴力遍历并快速幂 (°Д°)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> Ex,<span class="keyword">int</span> Mod)</span> </span>&#123;</span><br><span class="line">	Auto itR=Split(R+<span class="number">1</span>),itL=Split(L);</span><br><span class="line">	<span class="keyword">int</span> reg=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; itL!=itR; ++itL) reg=(reg+(itL-&gt;R-itL-&gt;L+<span class="number">1</span>)*Pow(itL-&gt;V,Ex,Mod))%Mod;</span><br><span class="line">	<span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ul>
<li><a href="https://www.luogu.com.cn/problem/CF896C" target="_blank" rel="noopener">CF896C</a></li>
<li><a href="https://www.luogu.com.cn/problem/CF915E" target="_blank" rel="noopener">CF915E</a></li>
</ul>
<p><del>曾经有很多数据结构题可以用珂朵莉树水过，但被几个毒瘤(<a href="https://www.luogu.com.cn/user/3296" target="_blank" rel="noopener">@noip</a> <a href="https://www.luogu.com.cn/user/6813" target="_blank" rel="noopener">@mrsrz</a> <a href="https://www.luogu.com.cn/user/115864" target="_blank" rel="noopener">@NaCly_Fish</a>)给Hack了</del></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>珂朵莉树是<strong>随机数据</strong>下表现良好的数据结构，但在非随机数据下<strong>极易被Hack</strong>，因此一般情况下只作为骗分或对拍使用。</p>
<p><a href="http://codeforces.com/blog/entry/56135" target="_blank" rel="noopener">发明者的blog</a></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>暴力数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
