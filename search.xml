<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第二阶段总结</title>
    <url>/2020/03/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h3><h4 id="语言转换-模拟"><a href="#语言转换-模拟" class="headerlink" title="语言转换(模拟)"></a>语言转换(模拟)</h4><p>一道模拟题，需要注意细节的问题，考试的时候写锅了，惨遭报零 QAQ。</p>
<h4 id="相互攻击-二分答案"><a href="#相互攻击-二分答案" class="headerlink" title="相互攻击(二分答案)"></a>相互攻击(二分答案)</h4><p><code>最大化最近的两个总统之间的距离</code>，将问题转化为 “是否存在一种安排使距离不大于 $Len$ “，可以用贪心进行判断，二分 $Len$ 即可。</p>
<h4 id="战争游戏-Tanjan-树形DP"><a href="#战争游戏-Tanjan-树形DP" class="headerlink" title="战争游戏(Tanjan+树形DP)"></a>战争游戏(Tanjan+树形DP)</h4><p>考虑点与点之间必须经过的只有割点，如果在同一个点双联通分量中的话，则没有必经的点，那么只需要把所有的点双联通分量缩点，之后形成一棵树的结构，在树上计算经过每个点的点对数量成了一个简单的树形动归，就可以解决了。</p>
<h3 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h3><h4 id="钻石交易-DP-最短路径"><a href="#钻石交易-DP-最短路径" class="headerlink" title="钻石交易(DP+最短路径)"></a>钻石交易(DP+最短路径)</h4><p>用 $f_{S,i}$ 表示当前已卖掉的钻石集合为 $S$ 、走到了编号为 $i$ 的城市时身上最多能剩多少钱。状态的转移有两种方式：选择在当前的城市卖掉某颗钻石或者走到另外一个城市。不难看出，$S$ 的每一阶段内其实是最短路径问题，可以使用 SPFA 或 Dijkstra 算法解决。</p>
<h4 id="放棋子-数学推导"><a href="#放棋子-数学推导" class="headerlink" title="放棋子(数学推导)"></a>放棋子(数学推导)</h4><p>待补</p>
<h4 id="画矩形-分治"><a href="#画矩形-分治" class="headerlink" title="画矩形(分治)"></a>画矩形(分治)</h4><p>对时间分治。发现这是一个非常经典的能够用扫描线解决的问题。做法非常简单,只需要维护一个扫描线从下往上扫描,利用一维的能够维护区间加减的数据结构维护当前扫描线的每一段被多少个矩形覆盖,同时完成扫描线上的询问即可.这样做需要将每个矩形的上下两边看成两个事件,扫描线扫过下边的时候给矩形的左右两边围城的区间加1,扫过上边的时候给矩形的左右两边围城的区间减一。所以时间复杂度是按照 $y$ 坐标排序所有事件和询问的复杂度 $O(n \log n)$ 加上数据结构的复杂度 $O(n \log n)$ 。</p>
<p>  有了这个算法,再利用对时间分治扩展到插入和询问相间就不难了。算法每次将区间分成两段,提取出前面一段插入的矩形和后面一段的询问,这就变成了上面所说的问题。然后,再分别对前面一段和后面一段调用自身递归下去并将答案累加,问题就解决了。</p>
<h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><h4 id="折纸-计算"><a href="#折纸-计算" class="headerlink" title="折纸(计算)"></a>折纸(计算)</h4><p>手算一波即可。</p>
<h4 id="二叉查找树-线段树"><a href="#二叉查找树-线段树" class="headerlink" title="二叉查找树(线段树)"></a>二叉查找树(线段树)</h4><p>每一次插入一个数 $x$ 时，可以证明它的父节点只有两种可能：已经插入的数中刚好比  $x$ 小的数 $a$ ，或刚好比 $x$ 大的数 $b$ 。如果记录了 $a$ 和 $b$ 的深度 $D[a]$ ， $D[b]$ ，则 $D[x]= \max (D[a],D[b])$ 。只要能快速找 $a$ , $b$ 即可。可用线段树或双向链表等之类方法都可快速实现。</p>
<h4 id="游戏-状压DP"><a href="#游戏-状压DP" class="headerlink" title="游戏(状压DP)"></a>游戏(状压DP)</h4><p>因为 $511$ 的二进制为 $111111111$ ，很容易联想到状态压缩。设 $F_{i,S}$ 表示游戏进行到第 $i$ 轮， $S$ 表示有哪些位已经是 $1$ 或 $0$ 。用 $S_c$ 表示哪些卡片没有取。但是 $S_c$ 十分庞大，不能直接记录。$S_c$ 中的数分两类：一类是不影响状态 $S$ 的数，只要记录个数即可；另一类是影响状态 $S$ 的数，不用记录，可用通过 $S$ 看哪些数对它有影响，需要时重新计算即可。</p>
<h3 id="2-12"><a href="#2-12" class="headerlink" title="2.12"></a>2.12</h3><h4 id="立方体-打表-枚举？"><a href="#立方体-打表-枚举？" class="headerlink" title="立方体(打表+枚举？)"></a>立方体(打表+枚举？)</h4><p>将全部 24 种情况打表打出来，然后 $O(24^{N-1})$ 直接枚举即可。</p>
<h4 id="匹配数-状压DP"><a href="#匹配数-状压DP" class="headerlink" title="匹配数(状压DP)"></a>匹配数(状压DP)</h4><p>用 $F_{i,S}$ 表示记录到第 $i$个字符，有哪些模式匹配（$S$ 二进制记录集合状态）时的方案数。</p>
<h4 id="Byte大陆-二分答案"><a href="#Byte大陆-二分答案" class="headerlink" title="Byte大陆(二分答案)"></a>Byte大陆(二分答案)</h4><p>枚举删掉环上的一条边，破环成树，然后二分长度。</p>
<h3 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h3><h4 id="环球旅行"><a href="#环球旅行" class="headerlink" title="环球旅行"></a>环球旅行</h4><p>待补</p>
<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>待补</p>
<h4 id="wyh"><a href="#wyh" class="headerlink" title="wyh"></a>wyh</h4><p>待补</p>
<h3 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h3><h4 id="交通灯-最短路"><a href="#交通灯-最短路" class="headerlink" title="交通灯(最短路)"></a>交通灯(最短路)</h4><blockquote>
<p>对于一个点，只需知道到达该结点的最早时间。（晚了一定不会更优）。但是转移时可能需要等待一段时间才能出发。设当前点为u，指向点为v。考虑转移：容易求出在当前时刻点 $u$，$v$ 的颜色 $color$ 和剩余时间 $rest$ ,接着求解最小的等待时间即可。</p>
</blockquote>
<h4 id="砍树-贪心"><a href="#砍树-贪心" class="headerlink" title="砍树(贪心)"></a>砍树(贪心)</h4><blockquote>
<p>分析题目可知，每次删去的必为一条完整的链。（若删去的不是一条完整的链，叶子结点的个数必定不会减少）</p>
<p>这里定义 <strong>从 $u$ 出发完整的链</strong>： $u$ 为叶子结点（链的底端），$v$ 为 $u$ 的祖先中满足子节点数等于1的深度最小的结点（链的顶端），$u \to v$ 即为从 $u$ 出发的一条完整的链。</p>
<p>由定义可知，删去这样的链一定会使得叶子数$-1$。</p>
<p>考虑贪心：将所有这样的完整的加放入堆中，以链的权值和为关键字，每次弹出最小值。</p>
<p>若链的顶端的父亲子节点数$&gt;1$,则将父亲的子节点数$-1$，将整体叶子结点数$-1$。</p>
<p>否则说明这条链还需要向上延伸（由于删去了一些链，使得剩下的链的长度可能增加了），从链顶向上爬找到新的顶端并更新权值，将新链加入堆中。</p>
<p>重复这样的操作直到总叶子数$=m$</p>
</blockquote>
<h4 id="最大连续子序列和-树链剖分"><a href="#最大连续子序列和-树链剖分" class="headerlink" title="最大连续子序列和(树链剖分)"></a>最大连续子序列和(树链剖分)</h4><p>相信大家都知道 $O(n)$ 求解最大子段和的方法，但是别忘了还有 $O(n \log n)$ 的分治算法。建立一颗线段树，每个节点记录最大前缀和、最大后缀和和最大子段和，合并时先更新最大前缀和、最大后缀和，再更新最大子段和。代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    Tree L=Seg[Ls],R=Seg[Rs];</span><br><span class="line">    Seg[Now].Sum=L.Sum+R.Sum;</span><br><span class="line">    Seg[Now].Left=<span class="built_in">max</span>(L.Left,L.Sum+R.Left);</span><br><span class="line">    Seg[Now].Right=<span class="built_in">max</span>(R.Right,R.Sum+L.Right);</span><br><span class="line">    Seg[Now].Res=<span class="built_in">max</span>(L.Right+R.Left,<span class="built_in">max</span>(L.Res,R.Res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是本题可以采用树链剖分的方法，线段树维护链上的最大子段和，每次 $O(\log^2 n)$ 查询两点之间的最大子段和。</p>
<p>另外建议做一下 <a href="https://www.luogu.com.cn/problem/SP1716" target="_blank" rel="noopener">SP1716 GSS3</a> 和 <a href="https://www.luogu.com.cn/problem/P2042" target="_blank" rel="noopener">[NOI2005]维护数列</a> 练习一下。</p>
<h3 id="2-15"><a href="#2-15" class="headerlink" title="2.15"></a>2.15</h3><h4 id="数列-数列"><a href="#数列-数列" class="headerlink" title="数列(数列)"></a>数列(数列)</h4><p>由数列的知识可知： $x_n = \dfrac{a^n \cdot (a + b -1) - b}{a - 1}$ ，由此即可判断 $\left\vert x_n\right\vert$ 是否趋于无穷。</p>
<h4 id="单词-DP"><a href="#单词-DP" class="headerlink" title="单词(DP)"></a>单词(DP)</h4><p>用 $F_{S_1,S_2,k}$ 表示在所有以 $S_1$  为前缀的字符串中，与字符串 $S_1 + S_2$ 的差为 $k$ 的字符串有多少个。</p>
<h4 id="分配-树链剖分"><a href="#分配-树链剖分" class="headerlink" title="分配(树链剖分)"></a>分配(树链剖分)</h4><blockquote>
<p>首先这题有一个结论：如果把一颗子树中所填的所有数字拿出来，它们一定是连续的一段数字。</p>
</blockquote>
<p>有了这个结论，这道题就好办了。考虑树链剖分，子树大小关系改变最多有 $\log n$ 次，这样即可解决。</p>
<h3 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h3><h4 id="回文串-回文自动机"><a href="#回文串-回文自动机" class="headerlink" title="回文串(回文自动机)"></a>回文串(回文自动机)</h4><p><a href="https://blog.csdn.net/Clove_unique/article/details/53750322" target="_blank" rel="noopener">对不起不会</a></p>
<h4 id="序列分割-斜率优化"><a href="#序列分割-斜率优化" class="headerlink" title="序列分割(斜率优化)"></a>序列分割(斜率优化)</h4><blockquote>
<p>首先，这题<strong>答案与切的顺序无关</strong>。<del>证明显然</del></p>
<p>考虑 DP ，设 $S_i = \sum_{i=1}^n a_i$ ，令 $F_{i,j}$ 表示前个 $i$ 数分 $j$ 次的最大得分，则有</p>
<script type="math/tex; mode=display">F_{i,j} = min (F_{k,j-1} + S_k \cdot (S_i - S_k))\space (0 \le k < i)</script><p>需要滚动数组存，以下用 $F_i$ 表示 $F_{i,j-1}$ </p>
<p>然后考虑当 $i$ 选 $j$ 转移优于 $k$ 时：</p>
<p>$F_j + S_i \cdot S_j - {S_j}^2 &gt; F_k + S_i \cdot S_k - {S_k}^2$</p>
<p>$\dfrac {F_j - {S_j}^2 - (F_k - {S_k}^2)} {- S_j - ( - Sk)} &gt; S_i$</p>
<p>把每个点看做 $P_i( - S_i,F_i - {S_i}^2)$ ，那么单调队列维护一个点集，斜率递增这些点形成了一个在第三象限的下凸包。</p>
<p>注意可能会出现 $a_i = 0$ ，导致存在 $S_i = S_j$ ，因此计算斜率应注意横坐标相同的情况，斜率为 $-\infty$ 。</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/blog/hongzy/solution-p3648" target="_blank" rel="noopener">转自</a></p>
<h4 id="连珠线-DP"><a href="#连珠线-DP" class="headerlink" title="连珠线(DP)"></a>连珠线(DP)</h4><p><a href="https://www.luogu.com.cn/blog/Fighter/solution-p3647" target="_blank" rel="noopener">对不起不会</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>First</title>
    <url>/2020/03/First/</url>
    <content><![CDATA[<a id="more"></a>
<p>First time</p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
